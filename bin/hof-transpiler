#!/usr/bin/env node

'use strict';

const parsed = require('../lib/parse-args')(process.argv.slice(2));
const getLanguage = (langPath) => langPath.split('/').pop();

let sources = parsed.sources;
let shared = parsed.shared;

var mkdirp = require('mkdirp');
var fs = require('fs');
var walk = require('walk');
var path = require('path');
var _ = require('underscore');
var underscoreDeepExtend = require('underscore-deep-extend');
_.mixin({deepExtend: underscoreDeepExtend(_)});
var rimraf = require('rimraf');

const parseFileSync = (filePath) => {
  try {
    return JSON.parse(fs.readFileSync(filePath, 'utf8'));
  } catch (error) {
    throw new Error(error);
  }
};

const directory = (root, dirStats, next, translationObject) => {
  var newBasePath = path.resolve(root.replace('/src', ''), dirStats.name);

  mkdirp(newBasePath, function (mkerr) {
    if (mkerr) {
      throw Error(mkerr);
    }
    translationObject[dirStats.name] = require('fs')
      .createWriteStream(
        path.resolve(root.replace('/src', ''),
          dirStats.name,
          'default.json'
        )
      );
    translationObject[dirStats.name].write('{');
    next();
  });
};

_.each(sources, function walking (src) {
  var walker = walk.walk(src);
  var writeFileStream = {};
  var firstFileForDir = {};

  /* eslint func-names:0 max-nested-callbacks:0 */
  walker.on('directory', function (root, dirStats, next) {
    directory(root, dirStats, next, writeFileStream);
  });

  walker.on('file', function (root, fileStats, next) {
    var lang = getLanguage(root);
    var readStream = fs.createReadStream(path.resolve(root, fileStats.name));

    if (!firstFileForDir[lang]) {
      writeFileStream[lang].write('"' + fileStats.name.replace('.json', '') + '": ');
      firstFileForDir[lang] = true;
    } else {
      writeFileStream[lang].write(',"' + fileStats.name.replace('.json', '') + '": ');
    }

    readStream.on('data', function (chunk) {
      writeFileStream[lang].write(chunk);
    });

    readStream.on('end', function () {
      next();
    });
  });

  walker.on('end', function () {
    _.each(writeFileStream, function (writerStream) {
      var sharedMap = {};

      shared.forEach(function (sharedSource) {
        walk.walk(sharedSource).on('file', function (root, fileStats, next) {
          var lang = getLanguage(root);
          var streamLang = getLanguage(path.parse(writerStream.path).dir);
          var fileName = fileStats.name.replace('.json', '');
          let current;
          let strung;
          let combined;

          sharedMap[streamLang] = sharedMap[streamLang] || {};
          sharedMap[lang] = sharedMap[lang] || {};
          sharedMap[lang][fileName] = parseFileSync(path.resolve(root, fileStats.name));

          current = sharedMap[streamLang];

          combined = Object.assign(current, parseFileSync(writerStream.path));
          strung = JSON.stringify(combined, null, '\t');

          fs.writeFileSync(writerStream.path, strung, 'utf8');
          next();
        });
      });

      writerStream.end('}');
    });
  });
});
